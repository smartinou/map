//.$file${Logging::../src::Logger2.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: PFPP.qm
// File:  ${Logging::../src::Logger2.cpp}
//
// This code has been generated by QM 5.1.3 <www.state-machine.com/qm/>.
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
// All your changes in these sections will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${Logging::../src::Logger2.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// *******************************************************************************
//
// Project: Logging.
//
// Module: Logger.
//
// *******************************************************************************

//! \file
//! \brief Logger class.
//! \ingroup qp_ao

// ******************************************************************************
//
//        Copyright (c) 2018-2021, Pleora Technologies, All rights reserved.
//
// ******************************************************************************

// ******************************************************************************
//                              INCLUDE FILES
// ******************************************************************************

// This module.
#include "Logger2.h"

// Standard Libraries.
//#include <format>
#include <map>
#include <cstdarg>

// ******************************************************************************
//                       DEFINED CONSTANTS AND MACROS
// ******************************************************************************

// ******************************************************************************
//                         TYPEDEFS AND STRUCTURES
// ******************************************************************************

// ******************************************************************************
//                            FUNCTION PROTOTYPES
// ******************************************************************************

namespace Logger {

// ******************************************************************************
//                             GLOBAL VARIABLES
// ******************************************************************************

static std::map<std::string, std::pair<QP::QSignal, LogLevel::prio>> sCategories;

// ******************************************************************************
//                            EXPORTED FUNCTIONS
// ******************************************************************************

auto AddCategory(
    char const * const aCategoryStr,
    QP::QSignal const aEventSignal,
    LogLevel::prio const aMaxLevel
) noexcept -> bool
{
    auto const lPair = std::make_pair(aEventSignal, aMaxLevel);
    auto const lResult = sCategories.insert_or_assign(aCategoryStr, lPair);

    return lResult.second;
}


auto Log(
    LogLevel::prio const aLevel,
    char const * const aFileStr,
    unsigned int const aLine,
    char const * const aFunctionStr,
    char const * const aCategoryStr,
    char const * const aFormatStr,
    ...
) -> bool
{

    // Check for log level threshold (global and per category).
    auto const lCategory = GetCategory(aCategoryStr);
    if (!lCategory) {
        return false;
    }
    // Category is active: check if requested level w/r to max threshold.
    auto const [lEventSig, lPrio] = lCategory.value();
    if (aLevel > lPrio) {
        return false;
    }

    // Create the Log event and publish it to QP framework!
    auto const lLogEvent = Q_NEW(
        Logging::Event::LogMsg,
        lEventSig,
        aLevel,
        aCategoryStr
    );

    if (nullptr != lLogEvent) {
        // "file: <file_name>(line:column) `<function_name>`: <format_string>"
#if 0
        std::stringstream lSS{};
        lSS << "file: ";
        lSS << aFileStr;
        lSS << "(";
        lSS << aLine;
        lSS << ":";
        lSS << 0;
        lSS << ") `";
        lSS << aFunctionStr;
        lSS << "`: ";
        lSS << aFormatStr;

        // Concatenate variadics if any.
        std::va_list lArgs;
        va_start(lArgs, aFormatStr);
        auto lResult = vsnprintf(lStr.data(), lStr.size(), aFormatStr/*lSS.str().c_str()*/, lArgs);
        va_end(lArgs);
#else
        std::array<char, sLineSize> lFormatStr{};
        auto const lOffset = snprintf(
            lFormatStr.data(),
            lFormatStr.size(),
            "file: %s(%u:%u) `%s`: %s",
            aFileStr,
            aLine,
            0,
            aFunctionStr,
            aFormatStr
        );

        std::va_list lArgs{};
        va_start(lArgs, aFormatStr);
        std::array<char, sLineSize> lStr{};
        auto lResult = vsnprintf(lStr.data() + lOffset, lStr.size() - lOffset, lFormatStr.data(), lArgs);
        va_end(lArgs);
#endif

        if (lResult > 0) {
            lLogEvent->mMsg = lStr.data();
#ifdef Q_SPY
            static QP::QSpyId const sLog{0U};
#endif // Q_SPY
            QP::QF::PUBLISH(lLogEvent, &sLog);
            return true;
        }
    }

    return false;
}


void AddSink(char const * const aCategoryStr, QP::QActive const * const aAO) noexcept {
    // Make the AO listener subscribe to the category.
    auto const lCategory = GetCategory(aCategoryStr);
    if (lCategory) {
        [[maybe_unused]] auto const [lEventSig, lPrio] = lCategory.value();
        aAO->subscribe(lEventSig);
    }
}

// ******************************************************************************
//                              LOCAL FUNCTIONS
// ******************************************************************************

auto GetCategory(std::string const &aCategoryStr) noexcept
    -> std::optional<std::pair<QP::QSignal, LogLevel::prio>>
{
    auto const lSearch = sCategories.find(aCategoryStr);
    if (lSearch != sCategories.cend()) {
        return lSearch->second;
    }

    return std::nullopt;
}


} // namespace Logger

// ******************************************************************************
//                                END OF FILE
// ******************************************************************************
