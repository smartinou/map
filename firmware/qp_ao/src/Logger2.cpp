//$file${Logging::../src::Logger2.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: PFPP.qm
// File:  ${Logging::../src::Logger2.cpp}
//
// This code has been generated by QM 4.5.1 (https://www.state-machine.com/qm).
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...###".."$end...###".
// All your changes in these sections will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//$endhead${Logging::../src::Logger2.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// *******************************************************************************
//
// Project: Logging.
//
// Module: Logger.
//
// *******************************************************************************

//! \file
//! \brief Logger class.
//! \ingroup qp_ao

// ******************************************************************************
//
//        Copyright (c) 2018-2021, Pleora Technologies, All rights reserved.
//
// ******************************************************************************

// ******************************************************************************
//                              INCLUDE FILES
// ******************************************************************************

// Standard Libraries.
#include <map>
#include <string>
#include <stdarg.h>

// This module.
#include "Logger2.h"

// ******************************************************************************
//                       DEFINED CONSTANTS AND MACROS
// ******************************************************************************

// ******************************************************************************
//                         TYPEDEFS AND STRUCTURES
// ******************************************************************************

// ******************************************************************************
//                            FUNCTION PROTOTYPES
// ******************************************************************************

// ******************************************************************************
//                             GLOBAL VARIABLES
// ******************************************************************************

namespace Logger {

static std::map<std::string, std::pair<unsigned int, LogLevel>> sCategories;

static LogLevel sGlobalLevel = LogLevel::prio::ERROR;

static LogLevel::prio constexpr sInvalidCategory = LogLevel::prio::DISABLED;

} // namespace Logger

// ******************************************************************************
//                            EXPORTED FUNCTIONS
// ******************************************************************************

namespace Logger {

LogLevel GetGlobalLevel(void) {
    return sGlobalLevel;
}


void SetGlobalLevel(LogLevel const aLevel) {
    sGlobalLevel = aLevel;
}


bool AddCategory(
    char const * const aCategoryName,
    unsigned int const aEventSignal,
    LogLevel::prio const aLevel
) {
    auto lPair = std::make_pair(aEventSignal, aLevel);
    auto lResult = sCategories.insert_or_assign(aCategoryName, lPair);

    return lResult.second;
}


LogLevel GetLogLevel(char const * const aCategoryName) {

    auto lSearch = sCategories.find(aCategoryName);
    if (lSearch != sCategories.end()) {
        auto lPair = lSearch->second;
        return lPair.second;
    }

    return sInvalidCategory;
}


unsigned int GetEventSignal(char const * const aCategoryName) {

    auto lSearch = sCategories.find(aCategoryName);
    if (lSearch != sCategories.end()) {
        auto lPair = lSearch->second;
        return lPair.first;
    }

    return 0;
}


bool Log(
    LogLevel const aLevel,
    Date const &aDate,
    Time const &aTime,
    char const * const aFileStr,
    unsigned int const aLine,
    char const * const aFunctionStr,
    char const * const aCategoryName,
    char const * const aFormatStr,
    ...
) {

    // Check for log level threshold (global and per category).
    LogLevel lCategoryLevel = GetLogLevel(aCategoryName);
    if (lCategoryLevel != sInvalidCategory) {
        if (aLevel < lCategoryLevel) {
            return false;
        }
    } else if (aLevel < Logger::sGlobalLevel) {
        return false;
    }

    // Create the Log event and publish it to QP framework!
    Logging::Event::LogEntry * const lLogEvent = Q_NEW(
        Logging::Event::LogEntry,
        GetEventSignal(aCategoryName),
        aLevel,
        aDate,
        aTime,
        aFileStr,
        aLine,
        aFunctionStr,
        aCategoryName
    );

    if (nullptr != lLogEvent) {
        // Concatenate variadics if any.
        va_list lArgs;
        va_start(lArgs, aFormatStr);
        vsprintf(&lLogEvent->mMsg[0], aFormatStr, lArgs);
        va_end(lArgs);
    }

    QP::QF::PUBLISH(lLogEvent, 0);
    return true;
}


void AddSink(QP::QActive * const aAO, char const * const aCategoryName) {
    // Make the AO listener subscribe to the category.
    unsigned int lEventSig = GetEventSignal(aCategoryName);
    aAO->subscribe(lEventSig);
}


} // namespace Logger

// ******************************************************************************
//                              LOCAL FUNCTIONS
// ******************************************************************************

// ******************************************************************************
//                                END OF FILE
// ******************************************************************************
