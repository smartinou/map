//.$file${Logging::../inc::Logger2.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: PFPP.qm
// File:  ${Logging::../inc::Logger2.h}
//
// This code has been generated by QM 5.1.3 <www.state-machine.com/qm/>.
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
// All your changes in these sections will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${Logging::../inc::Logger2.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#pragma once
// *******************************************************************************
//
// Project: Logging.
//
// Module: Logger.
//
// *******************************************************************************

//! \file
//! \brief Logger class.
//! \ingroup qp_ao

// ******************************************************************************
//
//        Copyright (c) 2018-2022, Pleora Technologies, All rights reserved.
//
// ******************************************************************************

// ******************************************************************************
//                              INCLUDE FILES
// ******************************************************************************

// QP Library.
#include <qpcpp.h>

// This module.
#include "LogLevel.h"
#include "Logging_Events.h"

// Standard Libraries.
#include <optional>
#include <source_location>
#include <string>

// ******************************************************************************
//                       DEFINED CONSTANTS AND MACROS
// ******************************************************************************
#if 1
#define LOG_FILENAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

// TODO: Verify that release builds with gcc define NDEBUG.
#if defined(_DEBUG) || !defined(NDEBUG)
#define LOG_DEBUG(aCategory, ...)  \
{                                  \
    Logger::Log(                   \
        LogLevel::prio::DEBUG,     \
        __FILE__,                  \
        __LINE__,                  \
        __FUNCTION__,              \
        aCategory,                 \
        __VA_ARGS__                \
    );                             \
}
#else
#define LOG_DEBUG(aCategory, ...)
#endif

#define LOG_INFO(aCategory, aDate, aTime, ...); \
{                                 \
    Logger::Log(                  \
        LogLevel::prio::INFO,     \
        LOG_FILENAME,             \
        __LINE__,                 \
        __FUNCTION__,             \
        aCategory,                \
        __VA_ARGS__               \
    );                            \
}

#define LOG_WARNING(aCategory, aDate, aTime, ...); \
{                                    \
    Logger::Log(                     \
        LogLevel::prio::WARNING,     \
        __FILE__,                    \
        __LINE__,                    \
        __FUNCTION__,                \
        aCategory,                   \
        __VA_ARGS__                  \
    );                               \
}

#define LOG_ERROR(aCategory, aDate, aTime, ...); \
{                                  \
    Logger::Log(                   \
        LogLevel::prio::ERROR,     \
        __FILE__,                  \
        __LINE__,                  \
        __FUNCTION__,              \
        aCategory,                 \
        __VA_ARGS__                \
    );                             \
}

#define LOG_CRITICAL(aCategory, aDate, aTime, ...); \
{                                     \
    Logger::Log(                      \
        LogLevel::prio::CRITICAL,     \
        __FILE__,                     \
        __LINE__,                     \
        __FUNCTION__,                 \
        aCategory,                    \
        __VA_ARGS__                   \
    );                                \
}
#endif

// ******************************************************************************
//                         TYPEDEFS AND STRUCTURES
// ******************************************************************************

// ******************************************************************************
//                            EXPORTED VARIABLES
// ******************************************************************************

// ******************************************************************************
//                                 EXTERNS
// ******************************************************************************

// ******************************************************************************
//                            EXPORTED FUNCTIONS
// ******************************************************************************

namespace Logger {

static constexpr auto sLineSize{1024};


auto AddCategory(
    char const * aCategoryStr,
    QP::QSignal aEventSignal,
    LogLevel::prio aMaxLevel = LogLevel::prio::ERROR
) noexcept -> bool;


auto Log(
    LogLevel::prio aLevel,
    char const * aFileStr,
    unsigned int aLine,
    char const * aFunctionStr,
    char const * aCategoryStr,
    char const * aFormatStr,
    ...
) -> bool;


[[nodiscard]] auto GetCategory(std::string const &aCategoryStr) noexcept
    -> std::optional<std::pair<QP::QSignal, LogLevel::prio>>;


template <typename... Args>
auto Log(
    LogLevel::prio const aLevel,
    std::string const aCategoryName,
    std::source_location const aLocation,// = std::source_location::current(),
    std::string const aFormatStr,
    Args&&... aArgs
) -> bool
{

    // Check for log level threshold (global and per category).
    auto const lCategory = GetCategory(aCategoryName);
    if (!lCategory) {
        return false;
    }
    // Category is active: check if requested level w/r to max threshold.
    auto const [lEventSig, lPrio] = lCategory.value();
    if (aLevel > lPrio) {
        return false;
    }

    auto const lLogMsg = Q_NEW(
        Logging::Event::LogMsg,
        lEventSig,
        aLevel,
        aCategoryName
    );

    if (nullptr != lLogMsg) {
#if 0
        std::string const lPreludeStr{
            std::format(
                "file: {}({}:{}) `{}`: ",
                aLocation.file_name(),
                aLocation.line(),
                aLocation.column(),
                aLocation.function_name()
            )
        };
        std::string lMsg{std::format(aMsg, aArgs)};
        std::string lStr{lPreludeStr + lMsg};

        auto lResult = snprintf(&lLogMsg.mMsg[0], sLineSize, "%s", lStr.c_str());
#else
        std::array<char, 256> lFormatStr;
        auto const lOffset = snprintf(
            lFormatStr.data(),
            lFormatStr.size(),
            "file: %s(%lu:%lu) `%s`: %s",
            aLocation.file_name(),
            aLocation.line(),
            aLocation.column(),
            aLocation.function_name(),
            aFormatStr.c_str()
        );

        std::array<char, 256> lStr;
        auto lResult = snprintf(
            lStr.data() + lOffset,
            lStr.size() - lOffset,
            lFormatStr.data(),
            aArgs...
        );
#endif

        if (lResult > 0) {
            lLogMsg->mMsg = lStr.data();
#ifdef Q_SPY
            static QP::QSpyId const sLog{0U};
#endif // Q_SPY
            QP::QF::PUBLISH(lLogMsg, &sLog);
            return true;
        }
    }

    return false;
}


void AddSink(char const * aCategoryStr, QP::QActive const * aAO) noexcept;


} // namespace Logger

// ******************************************************************************
//                                END OF FILE
// ******************************************************************************
