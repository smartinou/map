//.$file${Logging::../inc::Logger2.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: PFPP.qm
// File:  ${Logging::../inc::Logger2.h}
//
// This code has been generated by QM 5.1.3 <www.state-machine.com/qm/>.
// DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
// All your changes in these sections will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${Logging::../inc::Logger2.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#pragma once
// *******************************************************************************
//
// Project: Logging.
//
// Module: Logger.
//
// *******************************************************************************

//! \file
//! \brief Logger class.
//! \ingroup qp_ao

// ******************************************************************************
//
//        Copyright (c) 2018-2022, Pleora Technologies, All rights reserved.
//
// ******************************************************************************

// ******************************************************************************
//                              INCLUDE FILES
// ******************************************************************************

// QP Library.
#include <qpcpp.h>

// This module.
#include "LogLevel.h"
#include "Logging_Events.h"

// Standard Libraries.
#include <cstdarg>
//#include <format>
#include <map>
#include <optional>
#include <source_location>
#include <string>

// ******************************************************************************
//                       DEFINED CONSTANTS AND MACROS
// ******************************************************************************

// ******************************************************************************
//                         TYPEDEFS AND STRUCTURES
// ******************************************************************************

class Logger final {
public:
    static constexpr auto sLineSize {1024};

    auto AddCategory(
        std::string const &aCategoryStr,
        QP::QSignal aEventSignal,
        LogLevel::prio aMaxLevel = LogLevel::prio::ERROR
    ) noexcept -> bool;

    void AddSink(std::string const &aCategoryStr, QP::QActive const * aAO) noexcept;

    template <typename... Args>
    auto Log(
        LogLevel::prio const aLevel,
        std::string const &aCategoryStr,
        std::source_location const aLocation,
        std::string const &aFormatStr,
        Args&&... aArgs
    ) -> bool {

        // Check for log level threshold (global and per category).
        auto const lCategory = GetCategory(aCategoryStr);
        if (!lCategory) {
            return false;
        }
        // Category is active: check if requested level w/r to max threshold.
        auto const [lEventSig, lPrio] = lCategory.value();
        if (aLevel > lPrio) {
            return false;
        }

        auto const lLogMsg = Q_NEW(
            Logging::Event::LogMsg,
            lEventSig,
            aLevel,
            aCategoryStr
        );

        if (nullptr != lLogMsg) {
        // "file: <file_name>(line:column) `<function_name>`: <format_string>"
#if 0
            std::string const lPreludeStr{
                std::format(
                    "file: {}({}:{}) `{}`: ",
                    aLocation.file_name(),
                    aLocation.line(),
                    aLocation.column(),
                    aLocation.function_name()
                )
            };
            std::string lMsg{std::format(aMsg, aArgs)};
            std::string lStr{lPreludeStr + lMsg};

            auto lResult = snprintf(&lLogMsg.mMsg[0], sLineSize, "%s", lStr.c_str());
#elif 0
            // String stream doubles the code footprint!!!
            // Also doesn't solve the vargs problem.
            std::stringstream lSS{};
            lSS << "file: ";
            lSS << aFileStr;
            lSS << "(";
            lSS << aLine;
            lSS << ":";
            lSS << 0;
            lSS << ") `";
            lSS << aFunctionStr;
            lSS << "`: ";
            lSS << aFormatStr;

            // Concatenate variadics if any.
            std::va_list lArgs;
            va_start(lArgs, aFormatStr);
            auto lResult = vsnprintf(lStr.data(), lStr.size(), aFormatStr/*lSS.str().c_str()*/, lArgs);
            va_end(lArgs);
#else
            static constexpr auto lPrefixSize {256};
            std::array<char, lPrefixSize> lFormatStr;
            auto const lOffset = snprintf(
                lFormatStr.data(),
                lFormatStr.size(),
                "file: %s(%lu:%lu) `%s`: %s",
                aLocation.file_name(),
                aLocation.line(),
                aLocation.column(),
                aLocation.function_name(),
                aFormatStr.c_str()
            );

            std::array<char, sLineSize - lPrefixSize> lStr;
            auto lResult = snprintf(
                lStr.data() + lOffset,
                lStr.size() - lOffset,
                lFormatStr.data(),
                aArgs...
            );
#endif

            if (lResult > 0) {
                lLogMsg->mMsg = lStr.data();
#ifdef Q_SPY
                static QP::QSpyId const sLog{0U};
#endif // Q_SPY
                QP::QF::PUBLISH(lLogMsg, &sLog);
                return true;
            }
        }

        return false;
    }

private:
    using CategoryEntry = std::pair<QP::QSignal, LogLevel::prio>;
    [[nodiscard]] auto GetCategory(std::string const &aCategoryStr) noexcept
        -> std::optional<CategoryEntry>;

    std::map<std::string, CategoryEntry> mCategories {};
};

// ******************************************************************************
//                            EXPORTED VARIABLES
// ******************************************************************************

// ******************************************************************************
//                                 EXTERNS
// ******************************************************************************

// ******************************************************************************
//                            EXPORTED FUNCTIONS
// ******************************************************************************

// ******************************************************************************
//                                END OF FILE
// ******************************************************************************
