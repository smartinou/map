//****************************************************************************
// Model: calc.qm
// File:  ./calc.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${.::calc.cpp} .............................................................
#include "qep_port.h"  // QEP/C interface
#include "bsp.h"       // board support package
#include "calc.h"

//${SMs::Calc} ...............................................................
class Calc : public QP::QMsm {
private:
    double m_operand1;
    uint8_t m_operator;

public:
    Calc();

protected:
    static QP::QState initial(Calc * const me, QP::QEvt const * const e);
    static QP::QState on  (Calc * const me, QP::QEvt const * const e);
    static QP::QState on_e(Calc * const me);
    static QP::QState on_x(Calc * const me);
    static QP::QState on_i(Calc * const me);
    static QP::QMState const on_s;
    static QP::QState error  (Calc * const me, QP::QEvt const * const e);
    static QP::QState error_e(Calc * const me);
    static QP::QState error_x(Calc * const me);
    static QP::QMState const error_s;
    static QP::QState negated1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState negated1_e(Calc * const me);
    static QP::QState negated1_x(Calc * const me);
    static QP::QMState const negated1_s;
    static QP::QState ready  (Calc * const me, QP::QEvt const * const e);
    static QP::QState ready_e(Calc * const me);
    static QP::QState ready_x(Calc * const me);
    static QP::QState ready_i(Calc * const me);
    static QP::QMState const ready_s;
    static QP::QState result  (Calc * const me, QP::QEvt const * const e);
    static QP::QState result_e(Calc * const me);
    static QP::QState result_x(Calc * const me);
    static QP::QMState const result_s;
    static QP::QState begin  (Calc * const me, QP::QEvt const * const e);
    static QP::QState begin_e(Calc * const me);
    static QP::QState begin_x(Calc * const me);
    static QP::QMState const begin_s;
    static QP::QState operand1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand1_e(Calc * const me);
    static QP::QState operand1_x(Calc * const me);
    static QP::QMState const operand1_s;
    static QP::QState zero1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState zero1_e(Calc * const me);
    static QP::QState zero1_x(Calc * const me);
    static QP::QMState const zero1_s;
    static QP::QState int1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState int1_e(Calc * const me);
    static QP::QState int1_x(Calc * const me);
    static QP::QMState const int1_s;
    static QP::QState frac1  (Calc * const me, QP::QEvt const * const e);
    static QP::QState frac1_e(Calc * const me);
    static QP::QState frac1_x(Calc * const me);
    static QP::QMState const frac1_s;
    static QP::QState opEntered  (Calc * const me, QP::QEvt const * const e);
    static QP::QState opEntered_e(Calc * const me);
    static QP::QState opEntered_x(Calc * const me);
    static QP::QMState const opEntered_s;
    static QP::QState negated2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState negated2_e(Calc * const me);
    static QP::QState negated2_x(Calc * const me);
    static QP::QMState const negated2_s;
    static QP::QState operand2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState operand2_e(Calc * const me);
    static QP::QState operand2_x(Calc * const me);
    static QP::QMState const operand2_s;
    static QP::QState zero2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState zero2_e(Calc * const me);
    static QP::QState zero2_x(Calc * const me);
    static QP::QMState const zero2_s;
    static QP::QState int2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState int2_e(Calc * const me);
    static QP::QState int2_x(Calc * const me);
    static QP::QMState const int2_s;
    static QP::QState frac2  (Calc * const me, QP::QEvt const * const e);
    static QP::QState frac2_e(Calc * const me);
    static QP::QState frac2_x(Calc * const me);
    static QP::QMState const frac2_s;
    static QP::QState final  (Calc * const me, QP::QEvt const * const e);
    static QP::QState final_e(Calc * const me);
    static QP::QMState const final_s;
};


static Calc l_calc;    // the only instance of the Calc class

// global-scope definitions --------------------------------------
QP::QMsm * const the_calc = &l_calc;    // "opaque" pointer to MSM

//${SMs::Calc} ...............................................................
//${SMs::Calc::Calc} .........................................................
Calc::Calc()
  : QMsm(Q_STATE_CAST(&Calc::initial))
{}

//${SMs::Calc::SM} ...........................................................
QP::QState Calc::initial(Calc * const me, QP::QEvt const * const e) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &on_s,
        {
            Q_ACTION_CAST(&on_e), // entry
            Q_ACTION_CAST(&on_i), // initial tran.
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${SMs::Calc::SM::initial}
    BSP_clear();
    return QM_TRAN_INIT(&tatbl_);
}
//${SMs::Calc::SM::on} .......................................................
QP::QMState const Calc::on_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&on),
    Q_ACTION_CAST(&on_e),
    Q_ACTION_CAST(&on_x),
    Q_ACTION_CAST(&on_i)
};
// ${SMs::Calc::SM::on}
QP::QState Calc::on_e(Calc * const me) {
    BSP_message("on-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&on_s);
}
// ${SMs::Calc::SM::on}
QP::QState Calc::on_x(Calc * const me) {
    BSP_message("on-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&on_s);
}
// ${SMs::Calc::SM::on::initial}
QP::QState Calc::on_i(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &ready_s,
        {
            Q_ACTION_CAST(&ready_e), // entry
            Q_ACTION_CAST(&ready_i), // initial tran.
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${SMs::Calc::SM::on::initial}
    BSP_message("on-INIT;");
    return QM_TRAN_INIT(&tatbl_);
}
// ${SMs::Calc::SM::on}
QP::QState Calc::on(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::C}
        case C_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &on_s,
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&on_e), // entry
                    Q_ACTION_CAST(&on_i), // initial tran.
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::OFF}
        case OFF_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &final_s,
                {
                    Q_ACTION_CAST(&on_x), // exit
                    Q_ACTION_CAST(&final_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::error} ................................................
QP::QMState const Calc::error_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&error),
    Q_ACTION_CAST(&error_e),
    Q_ACTION_CAST(&error_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error_e(Calc * const me) {
    BSP_message("error-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&error_s);
}
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error_x(Calc * const me) {
    BSP_message("error-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&error_s);
}
// ${SMs::Calc::SM::on::error}
QP::QState Calc::error(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::negated1} .............................................
QP::QMState const Calc::negated1_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&negated1),
    Q_ACTION_CAST(&negated1_e),
    Q_ACTION_CAST(&negated1_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::negated1}
QP::QState Calc::negated1_e(Calc * const me) {
    BSP_message("negated1-ENTRY;");
    BSP_negate();
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&negated1_s);
}
// ${SMs::Calc::SM::on::negated1}
QP::QState Calc::negated1_x(Calc * const me) {
    BSP_message("negated1-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&negated1_s);
}
// ${SMs::Calc::SM::on::negated1}
QP::QState Calc::negated1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::negated1::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &zero1_s,
                {
                    Q_ACTION_CAST(&negated1_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&zero1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated1::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &int1_s,
                {
                    Q_ACTION_CAST(&negated1_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&int1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated1::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &frac1_s,
                {
                    Q_ACTION_CAST(&negated1_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&frac1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated1::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::negated1::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                ;
                status_ = QM_HANDLED();
            }
            // ${SMs::Calc::SM::on::negated1::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        // ${SMs::Calc::SM::on::negated1::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &begin_s,
                {
                    Q_ACTION_CAST(&negated1_x), // exit
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&begin_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::ready} ................................................
QP::QMState const Calc::ready_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&ready),
    Q_ACTION_CAST(&ready_e),
    Q_ACTION_CAST(&ready_x),
    Q_ACTION_CAST(&ready_i)
};
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_e(Calc * const me) {
    BSP_message("ready-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&ready_s);
}
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready_x(Calc * const me) {
    BSP_message("ready-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&ready_s);
}
// ${SMs::Calc::SM::on::ready::initial}
QP::QState Calc::ready_i(Calc * const me) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[2];
    } const tatbl_ = { // transition-action table
        &begin_s,
        {
            Q_ACTION_CAST(&begin_e), // entry
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${SMs::Calc::SM::on::ready::initial}
    BSP_message("ready-INIT;");
    return QM_TRAN_INIT(&tatbl_);
}
// ${SMs::Calc::SM::on::ready}
QP::QState Calc::ready(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::ready::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &zero1_s,
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&zero1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &int1_s,
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&int1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &frac1_s,
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&operand1_e), // entry
                    Q_ACTION_CAST(&frac1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::OPER}
        case OPER_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &opEntered_s,
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            me->m_operand1 = BSP_get_value();
            me->m_operator = Q_EVT_CAST(CalcEvt)->key_code;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::ready::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &ready_s,
                {
                    Q_ACTION_CAST(&ready_x), // exit
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&ready_i), // initial tran.
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::ready::result} ........................................
QP::QMState const Calc::result_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&result),
    Q_ACTION_CAST(&result_e),
    Q_ACTION_CAST(&result_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_e(Calc * const me) {
    BSP_message("result-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&result_s);
}
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result_x(Calc * const me) {
    BSP_message("result-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&result_s);
}
// ${SMs::Calc::SM::on::ready::result}
QP::QState Calc::result(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::ready::begin} .........................................
QP::QMState const Calc::begin_s = {
    &Calc::ready_s, // superstate
    Q_STATE_CAST(&begin),
    Q_ACTION_CAST(&begin_e),
    Q_ACTION_CAST(&begin_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_e(Calc * const me) {
    BSP_message("begin-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&begin_s);
}
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin_x(Calc * const me) {
    BSP_message("begin-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&begin_s);
}
// ${SMs::Calc::SM::on::ready::begin}
QP::QState Calc::begin(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::ready::begin::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::ready::begin::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[4];
                } const tatbl_ = { // transition-action table
                    &negated1_s,
                    {
                        Q_ACTION_CAST(&begin_x), // exit
                        Q_ACTION_CAST(&ready_x), // exit
                        Q_ACTION_CAST(&negated1_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::ready::begin::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::operand1} .............................................
QP::QMState const Calc::operand1_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&operand1),
    Q_ACTION_CAST(&operand1_e),
    Q_ACTION_CAST(&operand1_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_e(Calc * const me) {
    BSP_message("operand1-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&operand1_s);
}
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1_x(Calc * const me) {
    BSP_message("operand1-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&operand1_s);
}
// ${SMs::Calc::SM::on::operand1}
QP::QState Calc::operand1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand1::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &begin_s,
                {
                    Q_ACTION_CAST(&operand1_x), // exit
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&begin_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand1::OPER}
        case OPER_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &opEntered_s,
                {
                    Q_ACTION_CAST(&operand1_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            me->m_operand1 = BSP_get_value();
            me->m_operator = Q_EVT_CAST(CalcEvt)->key_code;
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand1::EQUALS}
        case EQUALS_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &result_s,
                {
                    Q_ACTION_CAST(&operand1_x), // exit
                    Q_ACTION_CAST(&ready_e), // entry
                    Q_ACTION_CAST(&result_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::operand1::zero1} ......................................
QP::QMState const Calc::zero1_s = {
    &Calc::operand1_s, // superstate
    Q_STATE_CAST(&zero1),
    Q_ACTION_CAST(&zero1_e),
    Q_ACTION_CAST(&zero1_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand1::zero1}
QP::QState Calc::zero1_e(Calc * const me) {
    BSP_message("zero1-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&zero1_s);
}
// ${SMs::Calc::SM::on::operand1::zero1}
QP::QState Calc::zero1_x(Calc * const me) {
    BSP_message("zero1-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&zero1_s);
}
// ${SMs::Calc::SM::on::operand1::zero1}
QP::QState Calc::zero1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand1::zero1::DIGIT_0}
        case DIGIT_0_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::on::operand1::zero1::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &int1_s,
                {
                    Q_ACTION_CAST(&zero1_x), // exit
                    Q_ACTION_CAST(&int1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand1::zero1::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &frac1_s,
                {
                    Q_ACTION_CAST(&zero1_x), // exit
                    Q_ACTION_CAST(&frac1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::operand1::int1} .......................................
QP::QMState const Calc::int1_s = {
    &Calc::operand1_s, // superstate
    Q_STATE_CAST(&int1),
    Q_ACTION_CAST(&int1_e),
    Q_ACTION_CAST(&int1_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand1::int1}
QP::QState Calc::int1_e(Calc * const me) {
    BSP_message("int1-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&int1_s);
}
// ${SMs::Calc::SM::on::operand1::int1}
QP::QState Calc::int1_x(Calc * const me) {
    BSP_message("int1-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&int1_s);
}
// ${SMs::Calc::SM::on::operand1::int1}
QP::QState Calc::int1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand1::int1::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &frac1_s,
                {
                    Q_ACTION_CAST(&int1_x), // exit
                    Q_ACTION_CAST(&frac1_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand1::int1::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::operand1::frac1} ......................................
QP::QMState const Calc::frac1_s = {
    &Calc::operand1_s, // superstate
    Q_STATE_CAST(&frac1),
    Q_ACTION_CAST(&frac1_e),
    Q_ACTION_CAST(&frac1_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand1::frac1}
QP::QState Calc::frac1_e(Calc * const me) {
    BSP_message("frac1-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&frac1_s);
}
// ${SMs::Calc::SM::on::operand1::frac1}
QP::QState Calc::frac1_x(Calc * const me) {
    BSP_message("frac1-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&frac1_s);
}
// ${SMs::Calc::SM::on::operand1::frac1}
QP::QState Calc::frac1(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand1::frac1::POINT}
        case POINT_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::on::operand1::frac1::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::opEntered} ............................................
QP::QMState const Calc::opEntered_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&opEntered),
    Q_ACTION_CAST(&opEntered_e),
    Q_ACTION_CAST(&opEntered_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_e(Calc * const me) {
    BSP_message("opEntered-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&opEntered_s);
}
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered_x(Calc * const me) {
    BSP_message("opEntered-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&opEntered_s);
}
// ${SMs::Calc::SM::on::opEntered}
QP::QState Calc::opEntered(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::opEntered::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &zero2_s,
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&zero2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &int2_s,
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&int2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &frac2_s,
                {
                    Q_ACTION_CAST(&opEntered_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&frac2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::opEntered::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::opEntered::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // transition-action table
                    &negated2_s,
                    {
                        Q_ACTION_CAST(&opEntered_x), // exit
                        Q_ACTION_CAST(&negated2_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::opEntered::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::negated2} .............................................
QP::QMState const Calc::negated2_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&negated2),
    Q_ACTION_CAST(&negated2_e),
    Q_ACTION_CAST(&negated2_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::negated2}
QP::QState Calc::negated2_e(Calc * const me) {
    BSP_message("negated2-ENTRY;");
    BSP_negate();
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&negated2_s);
}
// ${SMs::Calc::SM::on::negated2}
QP::QState Calc::negated2_x(Calc * const me) {
    BSP_message("negated2-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&negated2_s);
}
// ${SMs::Calc::SM::on::negated2}
QP::QState Calc::negated2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::negated2::DIGIT_0}
        case DIGIT_0_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &zero2_s,
                {
                    Q_ACTION_CAST(&negated2_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&zero2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated2::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &int2_s,
                {
                    Q_ACTION_CAST(&negated2_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&int2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated2::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[4];
            } const tatbl_ = { // transition-action table
                &frac2_s,
                {
                    Q_ACTION_CAST(&negated2_x), // exit
                    Q_ACTION_CAST(&operand2_e), // entry
                    Q_ACTION_CAST(&frac2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::negated2::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::negated2::OPER::[e->key=='-']}
            if (Q_EVT_CAST(CalcEvt)->key_code == KEY_MINUS) {
                ;
                status_ = QM_HANDLED();
            }
            // ${SMs::Calc::SM::on::negated2::OPER::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        // ${SMs::Calc::SM::on::negated2::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &opEntered_s,
                {
                    Q_ACTION_CAST(&negated2_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::operand2} .............................................
QP::QMState const Calc::operand2_s = {
    &Calc::on_s, // superstate
    Q_STATE_CAST(&operand2),
    Q_ACTION_CAST(&operand2_e),
    Q_ACTION_CAST(&operand2_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_e(Calc * const me) {
    BSP_message("operand2-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&operand2_s);
}
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2_x(Calc * const me) {
    BSP_message("operand2-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&operand2_s);
}
// ${SMs::Calc::SM::on::operand2}
QP::QState Calc::operand2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand2::CE}
        case CE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &opEntered_s,
                {
                    Q_ACTION_CAST(&operand2_x), // exit
                    Q_ACTION_CAST(&opEntered_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_clear();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand2::EQUALS}
        case EQUALS_SIG: {
            // ${SMs::Calc::SM::on::operand2::EQUALS::[BSP_eval()]}
            if (BSP_eval(me->m_operand1, me->m_operator, BSP_get_value())) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[4];
                } const tatbl_ = { // transition-action table
                    &result_s,
                    {
                        Q_ACTION_CAST(&operand2_x), // exit
                        Q_ACTION_CAST(&ready_e), // entry
                        Q_ACTION_CAST(&result_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::operand2::EQUALS::[else]}
            else {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // transition-action table
                    &error_s,
                    {
                        Q_ACTION_CAST(&operand2_x), // exit
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        // ${SMs::Calc::SM::on::operand2::OPER}
        case OPER_SIG: {
            // ${SMs::Calc::SM::on::operand2::OPER::[BSP_eval()]}
            if (BSP_eval(me->m_operand1, me->m_operator, BSP_get_value())) {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // transition-action table
                    &opEntered_s,
                    {
                        Q_ACTION_CAST(&operand2_x), // exit
                        Q_ACTION_CAST(&opEntered_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            // ${SMs::Calc::SM::on::operand2::OPER::[else]}
            else {
                static struct {
                    QP::QMState const *target;
                    QP::QActionHandler act[3];
                } const tatbl_ = { // transition-action table
                    &error_s,
                    {
                        Q_ACTION_CAST(&operand2_x), // exit
                        Q_ACTION_CAST(&error_e), // entry
                        Q_ACTION_CAST(0)  // zero terminator
                    }
                };
                status_ = QM_TRAN(&tatbl_);
            }
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::operand2::zero2} ......................................
QP::QMState const Calc::zero2_s = {
    &Calc::operand2_s, // superstate
    Q_STATE_CAST(&zero2),
    Q_ACTION_CAST(&zero2_e),
    Q_ACTION_CAST(&zero2_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand2::zero2}
QP::QState Calc::zero2_e(Calc * const me) {
    BSP_message("zero2-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&zero2_s);
}
// ${SMs::Calc::SM::on::operand2::zero2}
QP::QState Calc::zero2_x(Calc * const me) {
    BSP_message("zero2-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&zero2_s);
}
// ${SMs::Calc::SM::on::operand2::zero2}
QP::QState Calc::zero2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand2::zero2::DIGIT_0}
        case DIGIT_0_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::on::operand2::zero2::DIGIT_1_9}
        case DIGIT_1_9_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &int2_s,
                {
                    Q_ACTION_CAST(&zero2_x), // exit
                    Q_ACTION_CAST(&int2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand2::zero2::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &frac2_s,
                {
                    Q_ACTION_CAST(&zero2_x), // exit
                    Q_ACTION_CAST(&frac2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert((int)'0');
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${SMs::Calc::SM::on::operand2::int2} .......................................
QP::QMState const Calc::int2_s = {
    &Calc::operand2_s, // superstate
    Q_STATE_CAST(&int2),
    Q_ACTION_CAST(&int2_e),
    Q_ACTION_CAST(&int2_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand2::int2}
QP::QState Calc::int2_e(Calc * const me) {
    BSP_message("int2-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&int2_s);
}
// ${SMs::Calc::SM::on::operand2::int2}
QP::QState Calc::int2_x(Calc * const me) {
    BSP_message("int2-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&int2_s);
}
// ${SMs::Calc::SM::on::operand2::int2}
QP::QState Calc::int2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand2::int2::POINT}
        case POINT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &frac2_s,
                {
                    Q_ACTION_CAST(&int2_x), // exit
                    Q_ACTION_CAST(&frac2_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            BSP_insert((int)'.');
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        // ${SMs::Calc::SM::on::operand2::int2::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::on::operand2::frac2} ......................................
QP::QMState const Calc::frac2_s = {
    &Calc::operand2_s, // superstate
    Q_STATE_CAST(&frac2),
    Q_ACTION_CAST(&frac2_e),
    Q_ACTION_CAST(&frac2_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::on::operand2::frac2}
QP::QState Calc::frac2_e(Calc * const me) {
    BSP_message("frac2-ENTRY;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&frac2_s);
}
// ${SMs::Calc::SM::on::operand2::frac2}
QP::QState Calc::frac2_x(Calc * const me) {
    BSP_message("frac2-EXIT;");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&frac2_s);
}
// ${SMs::Calc::SM::on::operand2::frac2}
QP::QState Calc::frac2(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${SMs::Calc::SM::on::operand2::frac2::POINT}
        case POINT_SIG: {
            ;
            status_ = QM_HANDLED();
            break;
        }
        // ${SMs::Calc::SM::on::operand2::frac2::DIGIT_0, DIGIT_1_9}
        case DIGIT_0_SIG: // intentionally fall through
        case DIGIT_1_9_SIG: {
            BSP_insert(Q_EVT_CAST(CalcEvt)->key_code);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}
//${SMs::Calc::SM::final} ....................................................
QP::QMState const Calc::final_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&final),
    Q_ACTION_CAST(&final_e),
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${SMs::Calc::SM::final}
QP::QState Calc::final_e(Calc * const me) {
    BSP_message("final-ENTRY;");
    BSP_exit();
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&final_s);
}
// ${SMs::Calc::SM::final}
QP::QState Calc::final(Calc * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; // avoid compiler warning in case 'me' is not used
    return status_;
}

