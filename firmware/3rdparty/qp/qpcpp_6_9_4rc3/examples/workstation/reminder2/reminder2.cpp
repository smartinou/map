//.$file${.::reminder2.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: reminder2.qm
// File:  ${.::reminder2.cpp}
//
// This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${.::reminder2.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"
#include "bsp.hpp"

#include "safe_std.h"   // portable "safe" <stdio.h>/<string.h> facilities

Q_DEFINE_THIS_FILE

using namespace QP;

//............................................................................
enum ReminderSignals {
    CRUNCH_SIG = Q_USER_SIG, // the invented reminder signal
    ECHO_SIG,     // check the responsiveness of the system
    TERMINATE_SIG // terminate the application
};

//............................................................................
//.$declare${Events::ReminderEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${Events::ReminderEvt} ....................................................
class ReminderEvt : public QP::QEvt {
public:
    std::uint32_t iter;
};
//.$enddecl${Events::ReminderEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Active object class -----------------------------------------------------..
//.$declare${Components::Cruncher} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${Components::Cruncher} ...................................................
class Cruncher : public QP::QActive {
private:

    // internal variable
    double m_sum;

public:
    explicit Cruncher() noexcept
      : QActive(Q_STATE_CAST(&initial))
    {}

protected:
    Q_STATE_DECL(initial);
    Q_STATE_DECL(processing);
    Q_STATE_DECL(final);
};
//.$enddecl${Components::Cruncher} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//. Check for the minimum required QP version
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 6.8.0 or higher required
#endif
//.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$define${Components::Cruncher} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//.${Components::Cruncher} ...................................................
//.${Components::Cruncher::SM} ...............................................
Q_STATE_DEF(Cruncher, initial) {
    //.${Components::Cruncher::SM::initial}
    (void)e; // unused parameter

    QS_FUN_DICTIONARY(&Cruncher::processing);
    QS_FUN_DICTIONARY(&Cruncher::final);

    return tran(&processing);
}
//.${Components::Cruncher::SM::processing} ...................................
Q_STATE_DEF(Cruncher, processing) {
    QP::QState status_;
    switch (e->sig) {
        //.${Components::Cruncher::SM::processing}
        case Q_ENTRY_SIG: {
            ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG);
            reminder->iter = 0;
            POST(reminder, this);
            m_sum = 0.0;
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${Components::Cruncher::SM::processing::CRUNCH}
        case CRUNCH_SIG: {
            uint32_t i = Q_EVT_CAST(ReminderEvt)->iter;
            uint32_t n = i;
            i += 100U;
            for (; n < i; ++n) {
                if ((n & 1) == 0) {
                    m_sum += 1.0/(2*n + 1);
                }
                else {
                    m_sum -= 1.0/(2*n + 1);
                }
            }
            //.${Components::Cruncher::SM::processing::CRUNCH::[i<0x07000000U]}
            if (i < 0x07000000U) {
                ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG);
                reminder->iter = i;
                POST(reminder, me);
                status_ = Q_RET_HANDLED;
            }
            //.${Components::Cruncher::SM::processing::CRUNCH::[else]}
            else {
                PRINTF_S("pi=%16.14f\n", 4.0*m_sum);
                status_ = tran(&processing);
            }
            break;
        }
        //.${Components::Cruncher::SM::processing::ECHO}
        case ECHO_SIG: {
            PRINTF_S("Echo! pi=%16.14f\n", 4.0*m_sum);
            status_ = Q_RET_HANDLED;
            break;
        }
        //.${Components::Cruncher::SM::processing::TERMINATE}
        case TERMINATE_SIG: {
            status_ = tran(&final);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.${Components::Cruncher::SM::final} ........................................
Q_STATE_DEF(Cruncher, final) {
    QP::QState status_;
    switch (e->sig) {
        //.${Components::Cruncher::SM::final}
        case Q_ENTRY_SIG: {
            PRINTF_S("%s\n", "final-ENTRY;");
                     QP::QF::stop(); // terminate the application
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}
//.$enddef${Components::Cruncher} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// test harness ==============================================================

// Local-scope objects -------------------------------------------------------
static Cruncher l_cruncher;     // the Cruncher active object
QEvt const *l_cruncherQSto[10]; // Event queue storage for Cruncher AO
static QF_MPOOL_EL(ReminderEvt) l_smlPoolSto[20]; // storage for small pool

//............................................................................
int main(int argc, char *argv[]) {
    PRINTF_S("Reminder state pattern\nQP version: %s\n"
           "Press 'e' to echo the current value...\n"
           "Press ESC to quit...\n",
           QP::versionStr);

    BSP_init(argc, argv); // initialize the BSP
    QF::init(); // initialize the framework and the underlying RT kernel

    // publish-subscribe not used, no call to QF_psInit()

    QF::poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));

    // instantiate and start the active objects...
    l_cruncher.start(1U,
                     l_cruncherQSto, Q_DIM(l_cruncherQSto),
                     nullptr, 0U, (QEvt *)0);

    return QF::run(); // run the QF application
}
//............................................................................
void BSP_onKeyboardInput(uint8_t key) {
    switch (key) {
        case 'e': {
            static QEvt const echoEvt = { ECHO_SIG, 0U, 0U };
            l_cruncher.POST(&echoEvt, nullptr);
            break;
        }
        case '\033': { // ESC pressed?
            // NOTE: this constant event is statically pre-allocated.
            // It can be posted/published as any other event.
            //
            static QEvt const terminateEvt = { TERMINATE_SIG, 0U, 0U };
            l_cruncher.POST(&terminateEvt, nullptr);
            break;
        }
    }
}
